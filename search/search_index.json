{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"qwikfire","text":"<p>Decorate class methods with shell commands</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#qwikfire.qwikfire.VARS_RE","title":"<code>VARS_RE = re.compile('\\\\{\\\\{\\\\s*(\\\\w+)\\\\s*\\\\}\\\\}')</code>  <code>module-attribute</code>","text":"<p>Regex pattern for Jinja style variable substitution blocks</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFire","title":"<code>QwikFire</code>","text":"<p>Rapidly fires off short lived, synchronous, blocking, sequential shell commands in a working directory with exception handling, and logging.</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>class QwikFire:\n    \"\"\"Rapidly fires off short lived, synchronous, blocking, sequential shell commands in\n    a working directory with exception handling, and logging.\n    \"\"\"\n\n    def __init__(self, function: GFunc, e: type[QwikFireException], *commands: str):\n        \"\"\"Creates a new instance of QwikFire within the decorator for the annotated method\n\n        Args:\n            function (Callable[_P, _T]): the annotated decorated function\n            e (type[QwikFireException]): the wrapper exception type\n            *commands (str): the string array of commands to execute\n        \"\"\"\n        self._exception: Final[type[QwikFireException]] = e\n        LOG.debug(f\"__init__():  re-raised exception = {e.__name__}\")\n        self._commands = commands\n        LOG.debug(f\"__init__():  annotation commands = {commands}\")\n        self._function = function\n        LOG.debug(f\"__init__():  annotated function  = {function.__qualname__}\")\n\n    @property\n    def function(self) -&gt; GFunc:\n        return self._function\n\n    @property\n    def raises(self) -&gt; type[QwikFireException]:\n        \"\"\"Gets the wrapper exception class raised\n\n        Returns:\n            type[QwikFireException]: either QwikFireException or a subclass\n        \"\"\"\n        return self._exception\n\n    def _run(self, cmd: str, qfr: QwikFireResult | None, annotated_instance: Any, **kwargs: Any) -&gt; QwikFireResult:\n        # extract _xxxx kwargs intended for pass through to sh.Command\n        sh_args: dict[str, Any] = {}\n        for arg in kwargs:\n            if arg.startswith(\"_\"):\n                sh_args[arg] = kwargs[arg]\n                LOG.debug(f\"passing through '{arg}'='{kwargs[arg]}' to sh\")\n        # injected to override so return codes are accessible when not 0\n        sh_args[\"_return_cmd\"] = True\n\n        # perform substitutions using kwargs key value pairs on the command\n        LOG.debug(f\"Running command '{cmd}' for {annotated_instance} with kwargs = {kwargs}\")\n        substituted = _substitute_all(cmd, **kwargs)\n        cmd_args = split(substituted)\n        LOG.info(f\"split substituted command = {cmd_args}\")\n\n        # prepare sh.Command, raises CommandNotFound exception if which command fails\n        try:\n            sh_cmd = Command(cmd_args[0])\n        except CommandNotFound as raised:\n            LOG.exception(f\"CommandNotFound exception raised when building the command: '{cmd_args[0]}'\")\n            wrapper_exception = self._exception.__new__(self._exception)\n            wrapper_exception.__init__(f\"Failed executing command '{cmd}'\", raised, annotated_instance)\n            wrapper_exception.result = qfr  # for the sake of earlier run commands\n            if qfr:\n                qfr.exception(raised)\n            raise wrapper_exception from raised\n\n        # run the command providing additional arguments\n        try:\n            # trunk-ignore(pyright/reportUnknownVariableType)\n            result: RunningCommand = sh_cmd(cmd_args[1:], **sh_args)\n        except Exception as raised:\n            LOG.exception(f\"Exception raised when trying to run the command: '{cmd}'\")\n            wrapper_exception = self._exception.__new__(self._exception)\n            wrapper_exception.__init__(f\"Failed executing command '{cmd}'\", raised, annotated_instance)\n            wrapper_exception.result = qfr  # for the sake of earlier run commands\n            if qfr:\n                qfr.exception(raised)\n            raise wrapper_exception from raised\n\n        # create a QFR inst if not already created and append each command's results\n        if qfr is None:\n            # trunk-ignore(pyright/reportUnknownArgumentType)\n            qfr = QwikFireResult(annotated_instance, result)\n        else:\n            # trunk-ignore(pyright/reportUnknownArgumentType)\n            qfr.append(result)\n        return qfr\n\n    def run(self, annotated_instance: Any, **kwargs: Any) -&gt; QwikFireResult:\n        \"\"\"Runs one or more commands in the @qwikfire method annotation\n\n        Args:\n            annotated_instance (Any): the instance of the annotated user defined class\n\n        Returns:\n            QwikFireResult: the result of running the command[s]\n        \"\"\"\n        # use sh_defaults if provided by the annotated user defined class\n        sh_defaults = getattr(annotated_instance, \"sh_defaults\", None)\n        if callable(sh_defaults):\n            defaults = annotated_instance.sh_defaults(self._function)\n            LOG.info(f\"Using shell and variable defaults from {self}: '{defaults}'\")\n            for arg in defaults:\n                if not kwargs.get(arg):\n                    LOG.info(f\"Adding shell and variable default key '{arg}' with value '{defaults[arg]}'\")\n                    kwargs[arg] = defaults[arg]\n                else:\n                    LOG.info(f\"Not overriding '{arg}' with value '{defaults[arg]}': keeping value '{kwargs[arg]}'\")\n        else:\n            LOG.debug(f\"No sh_defaults() method detected on {self}\")\n\n        # cycle and run each command one after the other\n        qfr = self._run(self._commands[0], None, annotated_instance, **kwargs)\n        for ii in range(1, len(self._commands)):\n            cmd = self._commands[ii]\n            qfr = self._run(cmd, qfr, annotated_instance, **kwargs)\n        return qfr\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFire.raises","title":"<code>raises: type[QwikFireException]</code>  <code>property</code>","text":"<p>Gets the wrapper exception class raised</p> <p>Returns:</p> Type Description <code>type[QwikFireException]</code> <p>type[QwikFireException]: either QwikFireException or a subclass</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFire.__init__","title":"<code>__init__(function, e, *commands)</code>","text":"<p>Creates a new instance of QwikFire within the decorator for the annotated method</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[_P, _T]</code> <p>the annotated decorated function</p> required <code>e</code> <code>type[QwikFireException]</code> <p>the wrapper exception type</p> required <code>*commands</code> <code>str</code> <p>the string array of commands to execute</p> <code>()</code> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def __init__(self, function: GFunc, e: type[QwikFireException], *commands: str):\n    \"\"\"Creates a new instance of QwikFire within the decorator for the annotated method\n\n    Args:\n        function (Callable[_P, _T]): the annotated decorated function\n        e (type[QwikFireException]): the wrapper exception type\n        *commands (str): the string array of commands to execute\n    \"\"\"\n    self._exception: Final[type[QwikFireException]] = e\n    LOG.debug(f\"__init__():  re-raised exception = {e.__name__}\")\n    self._commands = commands\n    LOG.debug(f\"__init__():  annotation commands = {commands}\")\n    self._function = function\n    LOG.debug(f\"__init__():  annotated function  = {function.__qualname__}\")\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFire.run","title":"<code>run(annotated_instance, **kwargs)</code>","text":"<p>Runs one or more commands in the @qwikfire method annotation</p> <p>Parameters:</p> Name Type Description Default <code>annotated_instance</code> <code>Any</code> <p>the instance of the annotated user defined class</p> required <p>Returns:</p> Name Type Description <code>QwikFireResult</code> <code>QwikFireResult</code> <p>the result of running the command[s]</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def run(self, annotated_instance: Any, **kwargs: Any) -&gt; QwikFireResult:\n    \"\"\"Runs one or more commands in the @qwikfire method annotation\n\n    Args:\n        annotated_instance (Any): the instance of the annotated user defined class\n\n    Returns:\n        QwikFireResult: the result of running the command[s]\n    \"\"\"\n    # use sh_defaults if provided by the annotated user defined class\n    sh_defaults = getattr(annotated_instance, \"sh_defaults\", None)\n    if callable(sh_defaults):\n        defaults = annotated_instance.sh_defaults(self._function)\n        LOG.info(f\"Using shell and variable defaults from {self}: '{defaults}'\")\n        for arg in defaults:\n            if not kwargs.get(arg):\n                LOG.info(f\"Adding shell and variable default key '{arg}' with value '{defaults[arg]}'\")\n                kwargs[arg] = defaults[arg]\n            else:\n                LOG.info(f\"Not overriding '{arg}' with value '{defaults[arg]}': keeping value '{kwargs[arg]}'\")\n    else:\n        LOG.debug(f\"No sh_defaults() method detected on {self}\")\n\n    # cycle and run each command one after the other\n    qfr = self._run(self._commands[0], None, annotated_instance, **kwargs)\n    for ii in range(1, len(self._commands)):\n        cmd = self._commands[ii]\n        qfr = self._run(cmd, qfr, annotated_instance, **kwargs)\n    return qfr\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireException","title":"<code>QwikFireException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The root class of the exception hierarchy.</p> <p>Users can use this exception directly with @qwikfire annotations. Best to subclass it with specific meaning for the package or application qwikfire is being used on.</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>class QwikFireException(Exception):\n    \"\"\"The root class of the exception hierarchy.\n\n    Users can use this exception directly with @qwikfire annotations. Best to subclass it\n    with specific meaning for the package or application qwikfire is being used on.\n    \"\"\"\n\n    def __init__(self, message: str, e: Exception, annotated_instance: Any):\n        \"\"\"Creates a new QwikFireException wrapper exception. Used directly in annotations\n        or subclassed for package and application specific exceptions.\n\n        Args:\n            message (str): a message to describe the exception\n            e (Exception): the underlying shell related exception: see [sh exceptions](https://sh.readthedocs.io/en/latest/sections/command_class.html#exceptions)\n            annotated_instance (Any): the instance of the annotated class\n        \"\"\"\n        self._exception: Final[Exception] = e\n        self._annotated_instance = annotated_instance\n        super().__init__(message)\n\n    @property\n    def exception(self) -&gt; Exception:\n        \"\"\"Gets the underlying shell exception wrapped by this exception\n\n        Returns:\n            Exception: the underlying sh exception: see [sh exceptions](https://sh.readthedocs.io/en/latest/sections/command_class.html#exceptions)\n        \"\"\"\n        return self._exception\n\n    @property\n    def annotated_instance(self) -&gt; Any:\n        \"\"\"Gets the instance of the annotated class.\n\n        Returns:\n            Any: instance of the class annotated with the @qwikfire decorator annotation\n        \"\"\"\n        return self._annotated_instance\n\n    @property\n    def result(self) -&gt; Any:\n        \"\"\"Gets the QwikFireResults object.\n\n        TODO: Due to an ordering problem in this file (and the dependency between\n        QwikFireException and QwikFireResults) the result property uses Any.\n\n        Returns:\n            Any: the QwikFireResults with or without the command producing this exception\n        \"\"\"\n        return self._result\n\n    @result.setter\n    def result(self, result: Any) -&gt; None:\n        \"\"\"Sets the QwikFireResult object collected before this exception was raised.\"\"\"\n        self._result = result\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireException.annotated_instance","title":"<code>annotated_instance: Any</code>  <code>property</code>","text":"<p>Gets the instance of the annotated class.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>instance of the class annotated with the @qwikfire decorator annotation</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireException.exception","title":"<code>exception: Exception</code>  <code>property</code>","text":"<p>Gets the underlying shell exception wrapped by this exception</p> <p>Returns:</p> Name Type Description <code>Exception</code> <code>Exception</code> <p>the underlying sh exception: see sh exceptions</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireException.result","title":"<code>result: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the QwikFireResults object.</p> <p>TODO: Due to an ordering problem in this file (and the dependency between QwikFireException and QwikFireResults) the result property uses Any.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the QwikFireResults with or without the command producing this exception</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireException.__init__","title":"<code>__init__(message, e, annotated_instance)</code>","text":"<p>Creates a new QwikFireException wrapper exception. Used directly in annotations or subclassed for package and application specific exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>a message to describe the exception</p> required <code>e</code> <code>Exception</code> <p>the underlying shell related exception: see sh exceptions</p> required <code>annotated_instance</code> <code>Any</code> <p>the instance of the annotated class</p> required Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def __init__(self, message: str, e: Exception, annotated_instance: Any):\n    \"\"\"Creates a new QwikFireException wrapper exception. Used directly in annotations\n    or subclassed for package and application specific exceptions.\n\n    Args:\n        message (str): a message to describe the exception\n        e (Exception): the underlying shell related exception: see [sh exceptions](https://sh.readthedocs.io/en/latest/sections/command_class.html#exceptions)\n        annotated_instance (Any): the instance of the annotated class\n    \"\"\"\n    self._exception: Final[Exception] = e\n    self._annotated_instance = annotated_instance\n    super().__init__(message)\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult","title":"<code>QwikFireResult</code>","text":"<p>The run results of both single and multiple commands in an @qwikfire annotation</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>class QwikFireResult:\n    \"\"\"The run results of both single and multiple commands in an @qwikfire annotation\"\"\"\n\n    _exception: None | Exception\n\n    def __init__(self, annotated_instance: Any, commands: RunningCommand):\n        \"\"\"Creates an instance of QwikFireResult with its first mandatory command\n\n        Args:\n            annotated_instance (Any): the instance of the class whose methods are annotated\n            commands (RunningCommand): the commands in the annotation\n        \"\"\"\n        self._annotated_instance: Final[Any] = annotated_instance\n        self._results: Final[list[RunningCommand]] = []\n        self._results.append(commands)\n        self._exception = None\n\n    def exception(self, exception: Exception) -&gt; None:\n        self._exception = exception\n\n    def append(self, command: RunningCommand):\n        \"\"\"Append RunningCommands, used by annotations with more than one command\n\n        Args:\n            command (RunningCommand): an executed command's results\n        \"\"\"\n        self._results.append(command)\n\n    def result(self, index: Optional[int] = None) -&gt; RunningCommand:\n        \"\"\"Gets the first or only command result, RunningCommand, at index 0 or at a specific index\n\n        Args:\n            index (Optional[int], optional): the optional index or 0 is used\n\n        Returns:\n            RunningCommand: the command at the index\n        \"\"\"\n        if index is None:\n            return self._results[0]\n        else:\n            return self._results[index]\n\n    def _stdout(self) -&gt; bytes:\n        output: bytes = b\"\"\n        for r in self._results:\n            output += r.stdout\n        return output\n\n    def concat_stdout(self) -&gt; bytes:\n        \"\"\"Concatenates all command output to stdout into a single buffer\n\n        Returns:\n            bytes: a single buffer with every command's stdout appended\n        \"\"\"\n        retval: bytes = self._stdout()\n\n        if self._exception is None:\n            return retval\n        elif isinstance(self._exception, CommandNotFound):\n            retval += f\"command not found '{self._exception}'\".encode()\n            return retval\n        elif isinstance(self._exception, ErrorReturnCode):\n            retval += f\"non-zero return code exception = '{self._exception}'\".encode()\n            return retval\n        else:\n            retval += f\"unknown exception = '{self._exception}'\".encode()\n            return retval\n\n    def _stderr(self) -&gt; bytes:\n        output: bytes = b\"\"\n        for r in self._results:\n            output += r.stderr\n        return output\n\n    def concat_stderr(self) -&gt; bytes:\n        \"\"\"Concatenates all command error output to stderr into a single buffer\n\n        Returns:\n            bytes: a single buffer with every command's stderr appended\n        \"\"\"\n        retval: bytes = self._stderr()\n\n        if self._exception is None:\n            return retval\n        elif isinstance(self._exception, CommandNotFound):\n            retval += f\"command not found '{self._exception}'\".encode()\n            return retval\n        elif isinstance(self._exception, ErrorReturnCode):\n            retval += f\"non-zero return code exception = '{self._exception}'\".encode()\n            return retval\n        else:\n            retval += f\"unknown exception = '{self._exception}'\".encode()\n            return retval\n\n    @property\n    def results(self) -&gt; list[RunningCommand]:\n        \"\"\"Gets the list of all results\n\n        Returns:\n            list[RunningCommand]: all the results as an ordered list\n        \"\"\"\n        return self._results\n\n    @property\n    def annotated_instance(self) -&gt; Any:\n        \"\"\"Gets the instance of the annotated class\n\n        Returns:\n            Any: could be any user defined class\n        \"\"\"\n        return self._annotated_instance\n\n    @property\n    def exit_code(self, index: Optional[int] = 0) -&gt; int:\n        \"\"\"Gets the exit_code of the first/only RunningCommand result or at a specific index\n\n        Args:\n            index (Optional[int], optional): specific index to lookup the command's exit code\n\n        Returns:\n            int: the exit code of the command\n        \"\"\"\n        if self._exception and isinstance(self._exception, CommandNotFound):\n            return 1\n        elif self._exception and isinstance(self._exception, ErrorReturnCode):\n            # trunk-ignore(pyright/reportUnknownMemberType,pyright/reportAttributeAccessIssue)\n            return self._exception.exit_code\n        elif self._exception:\n            return 255\n        elif index is None:\n            return self._results[0].exit_code\n        else:\n            return self._results[index].exit_code\n\n    @property\n    def exit_codes(self) -&gt; int:\n        \"\"\"If all commands are successful, returns the sum of all exit_codes which will\n        almost always be zero unless `sh` _ok_codes kwarg is used.\n\n        If an exception is raised, returns the value of the last command's exception, returns\n        1 if command was not found or 255 on unknown exception types.\n\n        Returns:\n            int: 1 if a command was not found, or the exit code of the last failing command,\n                or the sum of all command result exit codes (zero unless _ok_codes are used)\n        \"\"\"\n        if self._exception and isinstance(self._exception, CommandNotFound):\n            return 1\n        elif self._exception and isinstance(self._exception, ErrorReturnCode):\n            # trunk-ignore(pyright/reportUnknownMemberType,pyright/reportAttributeAccessIssue)\n            return self._exception.exit_code\n        elif self._exception:\n            return 255\n\n        if len(self._results) == 1:\n            return self._results[0].exit_code\n        output: int = 0\n        for r in self._results:\n            output += r.exit_code\n        return output\n\n    @property\n    def stripped(self, encoding: Optional[str] = \"UTF-8\") -&gt; str:\n        \"\"\"Gets the decoded concatenated standard output with right and left whitespace stripped\n\n        Usually this is all that's ever needed to process the output if at all.\n\n        Args:\n            encoding (Optional[str], optional): use 'UTF-8' encoding by default\n\n        Returns:\n            str: the decoded concatenated standard output with right and left whitespace stripped\n        \"\"\"\n        if encoding is None:\n            return self.concat_stdout().decode(\"UTF-8\").rstrip().lstrip()\n        else:\n            return self.concat_stdout().decode(encoding).rstrip().lstrip()\n\n    @property\n    def stdout(self, encoding: Optional[str] = \"UTF-8\") -&gt; str:\n        \"\"\"Gets the decoded concatenated standard output\n\n        Args:\n            encoding (Optional[str], optional): use 'UTF-8' encoding by default\n\n        Returns:\n            str: the decoded concatenated standard output\n        \"\"\"\n        if encoding is None:\n            return self.concat_stdout().decode(\"UTF-8\")\n        else:\n            return self.concat_stdout().decode(encoding)\n\n    @property\n    def stderr(self, encoding: Optional[str] = \"UTF-8\") -&gt; str:\n        \"\"\"Gets the decoded concatenated standard error output\n\n        Args:\n            encoding (Optional[str], optional): use 'UTF-8' encoding by default\n\n        Returns:\n            str: the decoded concatenated standard error output\n        \"\"\"\n        if encoding is None:\n            return self.concat_stderr().decode(\"UTF-8\")\n        else:\n            return self.concat_stderr().decode(encoding)\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.annotated_instance","title":"<code>annotated_instance: Any</code>  <code>property</code>","text":"<p>Gets the instance of the annotated class</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>could be any user defined class</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.exit_code","title":"<code>exit_code: int</code>  <code>property</code>","text":"<p>Gets the exit_code of the first/only RunningCommand result or at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Optional[int]</code> <p>specific index to lookup the command's exit code</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the exit code of the command</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.exit_codes","title":"<code>exit_codes: int</code>  <code>property</code>","text":"<p>If all commands are successful, returns the sum of all exit_codes which will almost always be zero unless <code>sh</code> _ok_codes kwarg is used.</p> <p>If an exception is raised, returns the value of the last command's exception, returns 1 if command was not found or 255 on unknown exception types.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>1 if a command was not found, or the exit code of the last failing command, or the sum of all command result exit codes (zero unless _ok_codes are used)</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.results","title":"<code>results: list[RunningCommand]</code>  <code>property</code>","text":"<p>Gets the list of all results</p> <p>Returns:</p> Type Description <code>list[RunningCommand]</code> <p>list[RunningCommand]: all the results as an ordered list</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.stderr","title":"<code>stderr: str</code>  <code>property</code>","text":"<p>Gets the decoded concatenated standard error output</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>Optional[str]</code> <p>use 'UTF-8' encoding by default</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the decoded concatenated standard error output</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.stdout","title":"<code>stdout: str</code>  <code>property</code>","text":"<p>Gets the decoded concatenated standard output</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>Optional[str]</code> <p>use 'UTF-8' encoding by default</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the decoded concatenated standard output</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.stripped","title":"<code>stripped: str</code>  <code>property</code>","text":"<p>Gets the decoded concatenated standard output with right and left whitespace stripped</p> <p>Usually this is all that's ever needed to process the output if at all.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>Optional[str]</code> <p>use 'UTF-8' encoding by default</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the decoded concatenated standard output with right and left whitespace stripped</p>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.__init__","title":"<code>__init__(annotated_instance, commands)</code>","text":"<p>Creates an instance of QwikFireResult with its first mandatory command</p> <p>Parameters:</p> Name Type Description Default <code>annotated_instance</code> <code>Any</code> <p>the instance of the class whose methods are annotated</p> required <code>commands</code> <code>RunningCommand</code> <p>the commands in the annotation</p> required Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def __init__(self, annotated_instance: Any, commands: RunningCommand):\n    \"\"\"Creates an instance of QwikFireResult with its first mandatory command\n\n    Args:\n        annotated_instance (Any): the instance of the class whose methods are annotated\n        commands (RunningCommand): the commands in the annotation\n    \"\"\"\n    self._annotated_instance: Final[Any] = annotated_instance\n    self._results: Final[list[RunningCommand]] = []\n    self._results.append(commands)\n    self._exception = None\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.append","title":"<code>append(command)</code>","text":"<p>Append RunningCommands, used by annotations with more than one command</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>RunningCommand</code> <p>an executed command's results</p> required Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def append(self, command: RunningCommand):\n    \"\"\"Append RunningCommands, used by annotations with more than one command\n\n    Args:\n        command (RunningCommand): an executed command's results\n    \"\"\"\n    self._results.append(command)\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.concat_stderr","title":"<code>concat_stderr()</code>","text":"<p>Concatenates all command error output to stderr into a single buffer</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>a single buffer with every command's stderr appended</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def concat_stderr(self) -&gt; bytes:\n    \"\"\"Concatenates all command error output to stderr into a single buffer\n\n    Returns:\n        bytes: a single buffer with every command's stderr appended\n    \"\"\"\n    retval: bytes = self._stderr()\n\n    if self._exception is None:\n        return retval\n    elif isinstance(self._exception, CommandNotFound):\n        retval += f\"command not found '{self._exception}'\".encode()\n        return retval\n    elif isinstance(self._exception, ErrorReturnCode):\n        retval += f\"non-zero return code exception = '{self._exception}'\".encode()\n        return retval\n    else:\n        retval += f\"unknown exception = '{self._exception}'\".encode()\n        return retval\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.concat_stdout","title":"<code>concat_stdout()</code>","text":"<p>Concatenates all command output to stdout into a single buffer</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>a single buffer with every command's stdout appended</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def concat_stdout(self) -&gt; bytes:\n    \"\"\"Concatenates all command output to stdout into a single buffer\n\n    Returns:\n        bytes: a single buffer with every command's stdout appended\n    \"\"\"\n    retval: bytes = self._stdout()\n\n    if self._exception is None:\n        return retval\n    elif isinstance(self._exception, CommandNotFound):\n        retval += f\"command not found '{self._exception}'\".encode()\n        return retval\n    elif isinstance(self._exception, ErrorReturnCode):\n        retval += f\"non-zero return code exception = '{self._exception}'\".encode()\n        return retval\n    else:\n        retval += f\"unknown exception = '{self._exception}'\".encode()\n        return retval\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.QwikFireResult.result","title":"<code>result(index=None)</code>","text":"<p>Gets the first or only command result, RunningCommand, at index 0 or at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Optional[int]</code> <p>the optional index or 0 is used</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RunningCommand</code> <code>RunningCommand</code> <p>the command at the index</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def result(self, index: Optional[int] = None) -&gt; RunningCommand:\n    \"\"\"Gets the first or only command result, RunningCommand, at index 0 or at a specific index\n\n    Args:\n        index (Optional[int], optional): the optional index or 0 is used\n\n    Returns:\n        RunningCommand: the command at the index\n    \"\"\"\n    if index is None:\n        return self._results[0]\n    else:\n        return self._results[index]\n</code></pre>"},{"location":"modules/#qwikfire.qwikfire.qwikfire","title":"<code>qwikfire(e, *command)</code>","text":"<p>Decorator factory function to capture arguments</p> Source code in <code>qwikfire/qwikfire.py</code> <pre><code>def qwikfire(e: type[QwikFireException], *command: str) -&gt; GFunc:\n    \"\"\"Decorator factory function to capture arguments\"\"\"\n\n    def decorator(function: Callable[Concatenate[Any, QwikFire, _P], _T]) -&gt; GFunc:\n        \"\"\"Decorator function itself\"\"\"\n\n        @wraps(function)\n        def wrapper(self: Any, *args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n            \"\"\"The wrapper function calling target\"\"\"\n            qf = QwikFire(function, e, *command)\n            return function(self, qf, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"}]}